<html>
<head>
<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui-touch-punch/0.2.3/jquery.ui.touch-punch.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquerymobile/1.4.5/jquery.mobile.min.js"></script>
<style>
	/* Avoid scrolling with jQuery mobile */
	body {
		overflow: hidden!important;
	} 
	/* override min-height that is set as 300px by default in jQuery mobile */
	.ui-page.ui-page-active {
		min-height: auto !important;
	}
	.handle {
		position: absolute;
		bottom: -5px;
		right: -5px;
		border: 1px solid black;
		background-color: white;
		cursor: se-resize;
	}
	.selection {
		position: absolute;
		top: -5px;
		left: -5px;
		cursor: pointer;
	}
	.container {
		position: absolute;
		width: auto;
		height: auto;
	}
	.indicatorContainer {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		display: none;
	}
	.close {
		position: absolute;
		right: 0px;
		top: -1px;
		width: 11px;
		height: 11px;
		opacity: 0.5;
	}
	.close:hover {
		opacity: 1;
	}
	.close:before, .close:after {
		position: absolute;
		left: 5px;
		content: ' ';
		height: 12px;
		width: 1px;
		background-color: #333;
	}
	.close:before {
		transform: rotate(45deg);
	}
	.close:after {
		transform: rotate(-45deg);
	}
    
    #toolbarcontainer {
        position: absolute;
        width: 28px;
        height: 28px;
        top: -34px;
        right: 15px;
		z-index: 9999;
    }
    .toolbarbutton, .toolbartoggle {
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0px;
        left: 0px;
        border-radius: 14px;
        cursor: pointer;
        box-shadow: 2px 2px 3px #999;
        border: 1px solid #ccc;
        overflow: hidden;
        background-color: #fff;
    }

    .toolbarbutton {
        opacity: 0;
		background-repeat: no-repeat;
		background-position: center;
    }
    .disabled {
        cursor: not-allowed;
        background-color: #eee;
    }

    .toolbartoggle {
        display: inline-block;
    }
    .bar1, .bar2, .bar3 {
        width: 15px;
        height: 2px;
        background-color: #666;
        margin: 3px auto 0px auto;
        transition: 0.4s;
    }
    .open > .bar2 {
        opacity: 0;
    }
    .open > .bar1 {
        -webkit-transform: rotate(-45deg) translate(-4px, 4px);
        transform: rotate(-45deg) translate(-4px, 4px);
    }
    .open > .bar3 {
        -webkit-transform: rotate(45deg) translate(-3px, -3px);
        transform: rotate(45deg) translate(-3px, -3px);
    }
    #togglebutton > div:first-child {
        margin-top: 8px;
    }
    #buttondesc {
        position: absolute;
		top: 40px;
        right: 0px;
        border: 1px solid rgb(77, 144, 240);
        background-color: rgb(214, 233, 248);
		border-radius: 3px;
        opacity: 0;
        padding: 2px 10px 2px 10px;
    }
    #buttondesc > span {
        font-family: Arial;
    }
	#lockOverlay {
		display: none;
  		justify-content: center;
		position: absolute;
		top: 0px;
		left: 0px;
		width: 100%;
		height: 100%;
		z-index: 100;
	}
	#lockWarning {
		display: none;
		position: absolute;
		top: 10px;
		margin-left: auto;
		margin-right: auto;
		padding: 10px 15px;
		border: 1px solid #f5c6cb;
		border-radius: 5px;
		background-color: #f8d7da;
		color: #721c24;
		font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
	}
	.closeIcon {
		position: absolute;
		top: -6px;
		right: -6px;
        width: 16;
        height: 16px;
		cursor: pointer;
        border-radius: 8px;
        border: 1px solid #000;
		background-color: #FFF;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z'/%3E%3C/svg%3E");
		background-repeat: no-repeat;
		background-position: center;
    }
    .resetIcon {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M8.586 8.858l-4.95 4.95 5.194 5.194H10V19h1.172l3.778-3.778-6.364-6.364zM10 7.444l6.364 6.364 2.828-2.829-6.364-6.364L10 7.444zM14 19h7v2h-9l-3.998.002-6.487-6.487a1 1 0 0 1 0-1.414L12.12 2.494a1 1 0 0 1 1.415 0l7.778 7.778a1 1 0 0 1 0 1.414L14 19z'/%3E%3C/svg%3E");
    }
    .resetIconOff {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M8.586 8.858l-4.95 4.95 5.194 5.194H10V19h1.172l3.778-3.778-6.364-6.364zM10 7.444l6.364 6.364 2.828-2.829-6.364-6.364L10 7.444zM14 19h7v2h-9l-3.998.002-6.487-6.487a1 1 0 0 1 0-1.414L12.12 2.494a1 1 0 0 1 1.415 0l7.778 7.778a1 1 0 0 1 0 1.414L14 19z' fill='rgba(0,0,0,0.3)'/%3E%3C/svg%3E");
    }
	.exportIcon {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M4 19h16v-7h2v8a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-8h2v7zm9-10v7h-2V9H6l6-6 6 6h-5z'/%3E%3C/svg%3E");
	}
	.exportIconOff {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M4 19h16v-7h2v8a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-8h2v7zm9-10v7h-2V9H6l6-6 6 6h-5z' fill='rgba(0,0,0,0.3)'/%3E%3C/svg%3E");
	}
	.undoIcon {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M8 7v4L2 6l6-5v4h5a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H8z' /%3E%3C/svg%3E");
	}
	.undoIconOff {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M8 7v4L2 6l6-5v4h5a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H8z' fill='rgba(0,0,0,0.3)'/%3E%3C/svg%3E");
	}
	.redoIcon {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M16 7h-5a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h5V1l6 5-6 5V7z'/%3E%3C/svg%3E");
	}
	.redoIconOff {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M16 7h-5a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h5V1l6 5-6 5V7z' fill='rgba(0,0,0,0.3)'/%3E%3C/svg%3E");
	}
	.trashIcon {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm1 2H6v12h12V8zm-9 3h2v6H9v-6zm4 0h2v6h-2v-6zM9 4v2h6V4H9z'/%3E%3C/svg%3E");
	}
	.trashIconOff {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm1 2H6v12h12V8zm-9 3h2v6H9v-6zm4 0h2v6h-2v-6zM9 4v2h6V4H9z' fill='rgba(0,0,0,0.3)'/%3E%3C/svg%3E");
	}
	.lockIcon {
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M19 10h1a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V11a1 1 0 0 1 1-1h1V9a7 7 0 1 1 14 0v1zM5 12v8h14v-8H5zm6 2h2v4h-2v-4zm6-4V9A5 5 0 0 0 7 9v1h10z'/%3E%3C/svg%3E");
	}
	.lockIconOff { /* unlock */
		background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3E%3Cpath fill='none' d='M0 0h24v24H0z'/%3E%3Cpath d='M7 10h13a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V11a1 1 0 0 1 1-1h1V9a7 7 0 0 1 13.262-3.131l-1.789.894A5 5 0 0 0 7 9v1zm-2 2v8h14v-8H5zm5 3h4v2h-4v-2z'/%3E%3C/svg%3E");
	}
</style>
<script>
$(document).ready(function() {

	const ZINDEX = {
		INACTIVE_IMAGE: 0,
		ACTIVE_IMAGE: 10 ,
		LOCK_OVERLAY: 100
	};
	let _deviceType = null;
	let _indicatorsTimer = null;

	const features = [
		{
			selector: "#exportbutton",
			desc: "Exporter le projet",
			class: "exportIcon",
			action: function () {
				exportProject("file");
			},
			isActive: function () {
				return getImageCount() > 0;
			}
		},
		{
			selector: "#resetbutton",
			desc: "Réinitialiser le projet",
			class: "trashIcon",
			action: function () {
				removeAll();
			},
			isActive: function () {
				return getImageCount() > 0 && !isLocked();
			}
		},
		{
			selector: "#redobutton",
			desc: "Restaurer la dernière action",
			class: "redoIcon",
			action: function () {
				_actions.redo();
			},
			isActive: function () {
				return _actions.canRedo() && !isLocked();
			}
		},
		{
			selector: "#undobutton",
			desc: "Annuler la dernière action",
			class: "undoIcon",
			action: function () {
				_actions.undo();
			},
			isActive: function () {
				return _actions.canUndo() && !isLocked();
			}
		},
		{
			type: 'toggle',
			selector: "#lockunlock",
			desc: [
				'Verrouiller',
				"Déverrouiller"
			],
			class: 'lockIcon',
			action: function () {
				toggleLock();
			},
			isActive: function () {
				return isLocked() ? 1 : 0;
			}
		}
	];

	function Normalizer(referenceWidth) {
		this.referenceWidth = referenceWidth ?? frameSize().width;
	}
	Normalizer.prototype.normalize = function(value) {
		return value * frameSize().width / this.referenceWidth;
	}

	function ImageData(dataOrIndex, referenceWidth) {
		Normalizer.call(this, referenceWidth);

		if (dataOrIndex instanceof Object) {
			// The input parameter is an object containing the image data
			this.data = dataOrIndex;
		} else {
			// Input parameter is the index of the image from which we want to extract the date
			const containerElement = $(getContainerSelector(dataOrIndex));
			const imageElement = $(getImageSelector(dataOrIndex));
			
			this.data = {
				url: imageElement.attr("src"),
				position: {
					top: containerElement.position().top,
					left: containerElement.position().left
				},
				width: imageElement.width(),
				height: imageElement.height()
			}
		}
	};
	ImageData.prototype = Object.create(Normalizer.prototype);
	ImageData.prototype.normalize = function() {
		return {
			...this.data,
			position: {
				top: Normalizer.prototype.normalize.call(this, this.data.position.top),
				left: Normalizer.prototype.normalize.call(this, this.data.position.left)
			},
			width: Normalizer.prototype.normalize.call(this, this.data.width)
		}
	}
	ImageData.fromUrl = function(url) {
		return {
			url: url
		}
	};

	function Action(selector) {
		Normalizer.call(this);
		this.selector = selector;
	};
	Action.prototype = Object.create(Normalizer.prototype);
	Action.prototype.getElement = function() {
		return $(this.selector);
	}

	function AddAction(selector, index) {
		Action.call(this, selector);
		this.data = new ImageData(index);
		this.imageIndex = index;
	}
	AddAction.prototype = Object.create(Action.prototype);
	AddAction.prepareAction = function(selector) {
		// empty
	}
	AddAction.prototype.redo = function() {
		addImage(this.data.normalize(), this.imageIndex);
	}
	AddAction.prototype.undo = function() {
		removeImage(this.imageIndex, true);
	}

	function SetAction(selector, prevData, newData) {
		Action.call(this, selector);
		this.prevData = prevData;
		this.newData = newData;
	}
	SetAction.prototype = Object.create(Action.prototype);
	SetAction.prepareAction = function(selector) {
		// empty
	}
	SetAction.prototype.redo = function() {
		this.getElement().attr("src", this.newData.url);
	}
	SetAction.prototype.undo = function() {
		this.getElement().attr("src", this.prevData.url);
	}

	function DragAction(selector) {
		Action.call(this, selector);
		const element = $(selector);
		const elementPosition = element.position();
		this.initialPosition = { "top": element.attr("initialTop"), "left": element.attr("initialLeft") },
		this.finalPosition = { "top": elementPosition.top, "left": elementPosition.left };
	}
	DragAction.prototype = Object.create(Action.prototype);
	DragAction.prepareAction = function(selector) {
		const element = $(selector);
		const elementPosition = element.position();
		element.attr("initialTop", elementPosition.top);
		element.attr("initialLeft", elementPosition.left);
	}
	DragAction.prototype.setPosition = function(position) {
		this.getElement().css({
			top: this.normalize(position.top),
			left: this.normalize(position.left)
		})	
	}
	DragAction.prototype.redo = function() {
		this.setPosition(this.finalPosition);
	}
	DragAction.prototype.undo = function() {
		this.setPosition(this.initialPosition);
	}

	function ResizeAction(selector) {
		Action.call(this, selector);
		const element = this.getElement();
		this.initialWidth = element.attr("initialWidth");
		this.finalWidth = element.width();
	}
	ResizeAction.prototype = Object.create(Action.prototype);
	ResizeAction.prepareAction = function(selector) {
		const element = $(selector);
		element.attr("initialWidth", element.width());
	}
	ResizeAction.prototype.setSize = function(size) {
		this.getElement().css({
			width: this.normalize(size)
		})
	}
	ResizeAction.prototype.undo = function() {
		this.setSize(this.initialWidth);
	}
	ResizeAction.prototype.redo = function() {
		this.setSize(this.finalWidth);
	}

	function RemoveAction(index) {
		const selector = getImageSelector(index);
		Action.call(this, selector);
		this.data = new ImageData(index);
		this.imageIndex = index;
	}
	RemoveAction.prototype = Object.create(Action.prototype);
	RemoveAction.prepareAction = function(selector) {
		// empty
	}
	RemoveAction.prototype.redo = function() {
		removeImage(this.imageIndex, true);
	}
	RemoveAction.prototype.undo = function() {
		addImage(this.data.normalize(), this.imageIndex);
	}

	function BorderAction(property, prevValue, newValue) {
		Action.call(this, ""); // No need for a selector : global action
		this.property = property;
		this.prevValue = prevValue;
		this.newValue = newValue;
	}
	BorderAction.prototype = Object.create(Action.prototype);
	BorderAction.prototype.redo = function() {
		setBorder(this.property, this.newValue, ActionContext.FROM_UNDO_REDO);
	}
	BorderAction.prototype.undo = function() {
		setBorder(this.property, this.prevValue, ActionContext.FROM_UNDO_REDO);
	}

	function CompositeAction(actions) {
		this.actions = actions;
	}
	CompositeAction.prototype.redo = function() {
		this.actions.forEach(action => {
			action.redo();
		})
	}
	CompositeAction.prototype.undo = function() {
		this.actions.forEach(action => {
			action.undo();
		})
	}

	function Actions() {
		this.actions = [];
		this.actionPtr = -1;
		this.compositeActions = null;
	};
	Actions.prototype.canRedo = function() {
		return this.actions.length > 0 && this.actionPtr < this.actions.length - 1;
	}
	Actions.prototype.canUndo = function() {
		return this.actionPtr >= 0;
	}
	Actions.prototype.addAction = function(action, save = true) {
		if (this.compositeActions !== null) {
			// Compposite action is open
			this.compositeActions.push(action);
		} else {
			// If some undo has been triggered, the action pointer is less than the last action index
			// And then, if a new action is processed, we must remove all actioons after the current action pointer
			// -> set the length property to remove all elements after index (length -1)
			this.actions.length = this.actionPtr + 1;
			this.actions.push(action);
			this.actionPtr = this.actions.length - 1;
			updateFeatureStatus();
			if (save === true) {
				exportProject("save");
			}
		}
	};
	Actions.prototype.redo = function() {
		const action = this.actions[this.actionPtr + 1];
		action.redo();
		this.actionPtr++;
		updateFeatureStatus();
		exportProject("save");
	}
	Actions.prototype.undo = function() {
		const action = this.actions[this.actionPtr];
		action.undo();
		this.actionPtr--;
		updateFeatureStatus();
		exportProject("save");
	}
	Actions.prototype.isCompositeAction = function() {
		return this.compositeActions !== null;
	}
	Actions.prototype.beginCompositeAction = function() {
		this.compositeActions = [];
	}
	Actions.prototype.endCompositeAction = function(save) {
		const compositeAction = new CompositeAction(this.compositeActions);
		this.compositeActions = null;
		this.addAction(compositeAction, save);
	}

	const _actions = new Actions();

	const ActionContext = {
		FROM_MESSAGE: 0,
		FROM_UNDO_REDO: 1,
		FROM_RESIZE: 2
	}

	window.onmessage = (event) => {
		if (event.data) {
			const message = event.data;
			switch (message.action) {
			case "set":
				setImage(ImageData.fromUrl(message.image));
				break;
			case "add":
				addImage(ImageData.fromUrl(message.image));
				break;
			case "device":
				initDeviceType(message.device);
				break
			case "border":
				setBorder(message.property, message.value, ActionContext.FROM_MESSAGE);
				break
			case "import":
				importProject(message.data, message.clearBefore, message.source);
				break;
			}
		}
	};

	function sendMessage(msg) {
		window.parent.postMessage(msg, "*");
	}
	
	function sendUpdateMessage(count) {
		sendMessage({
			action: "update",
			count: count
		});
	}

	function updateFeatureStatus() {
		features.forEach(feature => {
			activateFunction(feature);
		});
	}
			
	function log(msg) {
		$("#log").append("<span>&nbsp;/&nbsp;" + msg + "</span>");
	}

	function checkLocked(func, argsArray) {
		if (isLocked()) {
			$("#unlockButton").off("vclick");
			$("#unlockButton").on("vclick", function() {
				toggleLock();
				func.apply(null, argsArray);
			});

			$("#lockWarning").stop();
			$("#lockWarning").show(100).delay(5000).hide(100);
			return true;
		}
		return false;
	}

	function isLocked() {
		return $('#lockOverlay').css('display') === 'flex';
	}

	function toggleLock() {
		let lIsLocked;
		if ($('#lockOverlay').css('display') === 'flex') {
			$("#lockWarning").stop();
			$("#lockWarning").hide();
			$('#lockOverlay').css('display', 'none');
			lIsLocked = false;
		} else {
			$('#lockOverlay').css('display', 'flex');
			lIsLocked = true;
		}
		updateFeatureStatus();
		exportProject("save");
		sendMessage({
			action: 'lock',
			isLocked: lIsLocked
		})
	}

	function frameSize() {
		return {
			width: $("body").width(),
			height: $("body").height()
		}
	}

	const initialImageWidth = 300;
	const handleSize = 10;
	const borderProperties = [];
	borderProperties['border-color'] = 'white';
	borderProperties['border-width'] = 2;
	const activeColor = "#66f542";
	const inactiveColor = "#666"

	const shadowSize = 5;
	
	let currentImage = -1;
	let imageResizing = -1;
	let previousDragX = 0;
	let previousDragY = 0;
	
	function getContainerSelector(imageIndex) {
		return `#container${imageIndex}`;
	}
	function getHandleSelector(imageIndex) {
		return `#handle${imageIndex}`;
	}
	function getImageSelector(imageIndex) {
		return `#image${imageIndex}`;
	}
	function getCloseSelector(imageIndex) {
		return `#close${imageIndex}`;
	}
	function getSelectionSelector(imageIndex) {
		return `#selection${imageIndex}`;
	}
	function getIndicatorContainerSelector(imageIndex) {
		return `#indicatorContainer${imageIndex}`;
	}

	function getFreeIndex() {
		let index = 0;
		while ($(getContainerSelector(index)).length > 0) {
			index++;
		}
		return index;
	}
	
	function getImageCount() {
		return $("div[class*='container']").length;
	}

	function getFirstValidIndex() {
		if (getImageCount() === 0) {
			return -1;
		}
		let index = 0;
		while ($(getContainerSelector(index)).length === 0) {
			index++;
		}
		return index;
	}
	
	function hideActiveIndicators() {
		showElement(false, getIndicatorContainerSelector(currentImage));
	}

	function setActiveImage(imageIndex) {
		// Remove all seelctions
		$(".selection").css({
			"background-color": inactiveColor
		})

		$(".container").css({
			"z-index": ZINDEX.INACTIVE_IMAGE
		})
		
		currentImage = imageIndex;

		if (imageIndex === -1) {
			return;
		}
		
		if (_deviceType === 'mobile') {
			// Hide all indicators
			$(".indicatorContainer").css({
				display: "none"
			})
		}
		
		// Set active selection
		$(getSelectionSelector(imageIndex)).css({
			"background-color": activeColor
		});
		$(getContainerSelector(imageIndex)).css({
			"z-index": ZINDEX.ACTIVE_IMAGE
		});
		if (_deviceType === 'mobile') {
			// Show Active indicators for 10 Seconds
			$(getIndicatorContainerSelector(imageIndex)).css({
				display: "block"
			})
			if (_indicatorsTimer !== null) {
				clearTimeout(_indicatorsTimer);
			}
			_indicatorsTimer = setTimeout(hideActiveIndicators, 10000);
		}
	}

	function getCssBorderProperty(property, value) {
		const propValue = borderProperties[property];
		let cssValue = {
			raw: propValue,
			css: propValue
		};
		switch (property) {
			case 'border-width':
			// the stored border width is a numnber
			// If it not zero, it should at least be 1
			let rawValue = propValue === 0 ? 0 : Math.max(1, Math.round(propValue));
			cssValue.raw = rawValue;
			cssValue.css = rawValue + 'px';
			break;
		}
		return cssValue;
	}

	function setBorder(property, newValue, actionContext) {

		// We can change the border size on resize while being locked
		if (actionContext != ActionContext.FROM_RESIZE) {
			// If the action is launched from wix (FROM_MESSAGE), the border has not been updated yet since locked.
			// Then, if we execute the action again after unlock, we have to send a message back to the parent
			// -> set the action context as null instead of FROM_MESSAGE
			// -> don't modify the action context otherwise
			const forwardActionContext = actionContext === ActionContext.FROM_MESSAGE ? null : actionContext;
			if (checkLocked(setBorder, [property, newValue, forwardActionContext])) {
				return;
			}
		}

		const prevValue = borderProperties[property];
		borderProperties[property] = newValue;
		const newCssValue = getCssBorderProperty(property);
		$("[id^=image]").css(property, newCssValue.css);
		
		if (actionContext != ActionContext.FROM_UNDO_REDO && actionContext != ActionContext.FROM_RESIZE) {
			// Don't create an action if:
			// - we are processing an undo or redo action
			// - we set the border size after a resize event
			_actions.addAction(new BorderAction(property, prevValue, newValue));
		}
		
		if (actionContext != ActionContext.FROM_MESSAGE) {
			// Don't send back a message if the change comes from a message
			sendMessage({
				action: 'border',
				property: property,
				value: newCssValue.raw // Send the transformed value to the parent frame = the real css raw value
			});
		}
	}
	
	function removeAll() {
		let index = 0;
		const isCompositeAction = _actions.isCompositeAction();

		if (!isCompositeAction) {
			_actions.beginCompositeAction();
		}

		while (getImageCount() > 0) {
			if ($(getContainerSelector(index)).length > 0) {
				removeImage(index);
			}
			index++;
		}

		if (!isCompositeAction) {
			_actions.endCompositeAction(true);
		}

		sendUpdateMessage(0);
		currentImage = -1;
	}
		
	function removeImage(imageIndex, actionContext) {
		const containerSelector = getContainerSelector(imageIndex);
		const imageSelector = getImageSelector(imageIndex);
		const handleSelector = getHandleSelector(imageIndex);
		const closeSelector = getCloseSelector(imageIndex);
		const selectionSelector = getSelectionSelector(imageIndex);
		const indicatorContainerSelector = getIndicatorContainerSelector(imageIndex);

		if (actionContext != ActionContext.FROM_UNDO_REDO) {
			// Don't create new action if we are running an undo/redo action
			_actions.addAction(new RemoveAction(imageIndex));
		}

		$(indicatorContainerSelector).off();
		$(handleSelector).off();
		$(closeSelector).off();
		$(selectionSelector).off();
		$(imageSelector).off();
		$(containerSelector).off();
		$(containerSelector).remove();
	}

	function exportProject(target) {
		const project = {
			// V 2.0 = Adding border size + color
			// V 3.0 = Adding image height
			// V 4.0 = adding lock inforation
			// V 5.0 = store border width as number
			version: 5.0, 
			images: [],
			containerWidth: frameSize().width,
			border: {
				color: borderProperties["border-color"],
				width: borderProperties["border-width"]
			},
			locked: isLocked()
		};
		const imageCount = getImageCount();
		for (let imageIndex = 0; project.images.length < imageCount; imageIndex++) {
			const containerElement = $(getContainerSelector(imageIndex));
			if (containerElement.length === 0) {
				continue;
			}
			const imageData = new ImageData(imageIndex);
			project.images.push(imageData.data);
		}
		sendMessage({
			action: "export",
			target: target,
			data: project
		})
	}
	
	function importProject(projectData, clearBefore, source) {

		if (checkLocked(importProject, [projectData, clearBefore, source])) {
			return;
		}
		
		_actions.beginCompositeAction();

		if (clearBefore === true) {
			removeAll();
		}

		if (projectData.version >= 2) {
			// Adding border color/width in V2
			setBorder("border-color", projectData.border.color);
			const borderWidth = 
				projectData.version < 5 ?
				Number(parseInt(projectData.border.width)) : // Was stored as css property, e.g. '5px', before v5
				projectData.border.width;
			
			if (!isNaN(borderWidth)) {
				// Scale the value
				const normalizer = new Normalizer(projectData.containerWidth);
				const scaledBorderWidth = normalizer.normalize(borderWidth);

				setBorder("border-width", scaledBorderWidth);
			}
		}
		
		const initialWidth = projectData.containerWidth;
		
		for (let imageIndex = 0; imageIndex < projectData.images.length; imageIndex++) {
			const imageData = new ImageData(projectData.images[imageIndex], initialWidth);
			addImage(imageData.normalize());
		}

		if (projectData.locked === true) { // V4
			toggleLock();
		}

		_actions.endCompositeAction(false);
	}

	let _lastEventTimestamp;
	function patchedClickHandler(f) {
		return function (event) {
			if (event.timeStamp === _lastEventTimestamp) return;
			f.bind(this)(); // The initial function must access the clicked element through 'this'
			_lastEventTimestamp = event.timeStamp;
		};
	}

	function Magnetizer(dragEventUi) {
		const normalizer = new Normalizer(1000);
		this.magneticTrigger = normalizer.normalize(Magnetizer.MAGNETIC_TRIGGER);
		this.magneticDistance = normalizer.normalize(Magnetizer.MAGNETIC_DISTANCE);
		this.horizontalConfig = {
			position: dragEventUi.position.left,
			size: dragEventUi.helper.width()
		};
		this.verticalConfig = {
			position: dragEventUi.position.top,
			size: dragEventUi.helper.height()
		};
	}

	// Magnetic parameters for 1000 pixels.
	Magnetizer.MAGNETIC_DISTANCE = 5;
	Magnetizer.MAGNETIC_TRIGGER = 30;

	Magnetizer.prototype.checkVerticalMagnetism = function(otherElement) {
		return this.checkMagnetism(this.verticalConfig, {
			position: otherElement.position().top,
			size: otherElement.height()
		});
	}
	Magnetizer.prototype.checkHorizontalMagnetism = function(otherElement) {
		return this.checkMagnetism(this.horizontalConfig, {
			position: otherElement.position().left,
			size: otherElement.width()
		});
	}
	Magnetizer.prototype.checkMagnetism = function(dragElement, otherElement) {

		// Try to align left (resp. top) side with right (resp. bottom) side of other image
		const left2RightDistance = Math.abs(dragElement.position - otherElement.position - otherElement.size);
		// Try to align left (resp. top) side with left (resp. top) side of other image
		const leftToLeftDistance = Math.abs(dragElement.position - otherElement.position);
		// Try to align right (resp. bottom) side with left (resp. top) side of other image
		const rightToLeftDistance = Math.abs(otherElement.position - dragElement.position - dragElement.size);
		// Try to align right (resp. bottom) side with right (resp. top) side of other image
		const rightToRightDistance = Math.abs(dragElement.position + dragElement.size - otherElement.position - otherElement.size);

		const distances = [left2RightDistance, leftToLeftDistance, rightToLeftDistance, rightToRightDistance];
		const minIndex = distances.reduce((minValueIndex, currentValue, currentIndex) => {
			return currentValue < distances[minValueIndex] ? currentIndex : minValueIndex;
		}, 0);
	
		if (distances[minIndex] > this.magneticTrigger) {
			return null;
		}

		let newDragPosition = null;

		switch (minIndex) {
			case 0: // left2RightDistance
				newDragPosition = otherElement.position + otherElement.size + this.magneticDistance;
				break;
			case 1: // leftToLeftDistance
				newDragPosition = otherElement.position;
				break;
			case 2: // rightToLeftDistance
				newDragPosition = otherElement.position - this.magneticDistance - dragElement.size;
				break;
			case 3: // rightToRightDistance
				newDragPosition = otherElement.position + otherElement.size - dragElement.size;
				break;
		}

		return newDragPosition;
	}

	function getClosestPosition(refPosition, possiblePositions) {
		let finalPosition = null;
		let minDelta = Number.MAX_VALUE;
		possiblePositions.forEach(currentPosition => {
			if (currentPosition === null) {
				return;
			}
			if (finalPosition === null) {
				finalPosition = currentPosition;
				minDelta = Math.abs(refPosition - currentPosition);
			} else {
				const currentDelta = Math.abs(refPosition - currentPosition);
				if (currentDelta < minDelta) {
					minDelta = currentDelta;
					finalPosition = currentPosition;
				}
			}
		});
		return finalPosition;
	}

	function checkMagnetic(event, ui) {
		if (event.shiftKey) {
			const magnetizer = new Magnetizer(ui);

			const imageCount = getImageCount();
			let index = 0;
			let checkedImages = 0;

			const leftPossibilities = [];
			const topPossibilities = [];

			while (checkedImages < imageCount) {
				const container = $(getContainerSelector(index++));
				if (container.length === 0) {
					continue;
				}
				checkedImages++;
				if (container.attr('id') === ui.helper.attr('id')) {
					continue;
				}

				// Align left side with right/left side of other image
				leftPossibilities.push(magnetizer.checkHorizontalMagnetism(container));
				// Align top side with top/bottom side of other image
				topPossibilities.push(magnetizer.checkVerticalMagnetism(container));
			}

			const finalLeftPosition = getClosestPosition(ui.position.left, leftPossibilities);
			const finalTopPosition = getClosestPosition(ui.position.top, topPossibilities);

			if (finalLeftPosition !== null) {
				ui.position.left = finalLeftPosition;
			}
			if (finalTopPosition !== null) {
				ui.position.top = finalTopPosition;
			}
		}
	}

	function addImage(imageData, index) {

		if (checkLocked(addImage, [imageData, index])) {
			return;
		}

		const availableSize = frameSize();

		const imageIndex = index ?? getFreeIndex();
		const containerId = `container${imageIndex}`;
		const imageId = `image${imageIndex}`;
		const handleId = `handle${imageIndex}`;
		const closeId = `close${imageIndex}`;
		const selectionId = `selection${imageIndex}`;
		const indicatorContainerId = `indicatorContainer${imageIndex}`;
		
		const image = `<img id="${imageId}" src="${imageData.url}">`;
		const resizeHandle = `<div class="handle" id="${handleId}"></div>`;
		const closeButton = `<div class="closeIcon" id="${closeId}"></div>`;
		const selectionIndicator = `<div class="selection" id="${selectionId}"></div>`;
		const indicatorContainer = `<div class="indicatorContainer" id="${indicatorContainerId}">${resizeHandle}${closeButton}${selectionIndicator}</div`;
		
		const newImage = $("body").add(`<div class="container" id="${containerId}">${image}${indicatorContainer}</div>`);
		$("body").append(newImage);

		const containerSelector = getContainerSelector(imageIndex);
		const handleSelector = getHandleSelector(imageIndex);
		const imageSelector = getImageSelector(imageIndex);
		const closeSelector = getCloseSelector(imageIndex);
		const selectionSelector = getSelectionSelector(imageIndex);
		const indicatorContainerSelector = getIndicatorContainerSelector(imageIndex);
		
		// Initialize size and positions
		$(handleSelector).css({
			width: handleSize,
			height: handleSize
		})
		$(selectionSelector).css({
			width: handleSize + 2,
			height: handleSize + 2,
			"border-radius": handleSize / 2,
			"background-color": inactiveColor
		})

		// Configure events
		if (_deviceType === 'mobile') {
			$(`${indicatorContainerSelector}, ${imageSelector}`).on('vclick', patchedClickHandler(function(event) {
				if (currentImage === imageIndex) {
					toggleElementDisplay(indicatorContainerSelector);
				} else {
					setActiveImage(imageIndex);
				}
			}));
		} else {
			$(indicatorContainerSelector).on('click', function() {
				setActiveImage(imageIndex);
			})
			$(containerSelector).on('mouseover', function() {
				showElement(true, indicatorContainerSelector);
			});
			$(containerSelector).on('mousemove', function() {
				showElement(true, indicatorContainerSelector);
			});
			$(containerSelector).on('mouseout', function() {
				if (imageResizing === -1) {			
					showElement(false, indicatorContainerSelector);
				}
			});
		}
		
		$(imageSelector).css({
			"box-shadow": shadowSize + "px " + shadowSize + "px " + shadowSize + "px #999999",
			"border-width": getCssBorderProperty("border-width").css,
			"border-color": getCssBorderProperty("border-color").css,
			"border-style": "solid"
		});
		$(indicatorContainerSelector).css({
			"cursor": "move",
		});
		
		// Handle mousedown
		$(handleSelector).on('vmousedown', function(event) {
			startResize(event, imageIndex);
			ResizeAction.prepareAction(imageSelector);
			// Error In case of mobile:
			// Unable to preventDefault inside passive event listener
			if (_deviceType === 'desktop') return false;
		});
		
		// Close image
		$(closeSelector).on('vclick', patchedClickHandler(function(event) {
			removeImage(imageIndex);
			sendUpdateMessage(getImageCount());
			// Update currentImage
			if (currentImage === imageIndex) {
				setActiveImage(getFirstValidIndex());
			}
		}));
		
		// Set image as active
		$(selectionSelector).on('vclick', patchedClickHandler(function(event) {
			setActiveImage(imageIndex);
		}));
	
		// Drag options
	    $(containerSelector).draggable({
			handle: `${indicatorContainerSelector}, ${imageSelector}`,
			cancel: handleSelector,
			containment: "parent",
			start: function (event, ui) {
				setActiveImage(imageIndex);
				DragAction.prepareAction(containerSelector)
			},
			stop: function (event, ui) {
				_actions.addAction(new DragAction(containerSelector));
			},
			drag: function( event, ui ) {
				checkMagnetic(event, ui);
			}
	    });

		// the initial width is a third of the available width
		const imageWidth = imageData.width ?? availableSize.width / 3;
		const imageLeft = imageData.position ? imageData.position.left : (availableSize.width - imageWidth) / 2;
		// the initial top is a 5th of the available height
		const imageTop = imageData.position ? imageData.position.top : availableSize.height / 5;
		
		$(imageSelector).css({
			width: imageWidth
		})
		$(containerSelector).css({
			top: imageTop,
			left: imageLeft
		});

		setActiveImage(imageIndex);
		sendUpdateMessage(getImageCount());
		if (index == null) {
			// register a new action only in case wa have not been called from a redo()
			_actions.addAction(new AddAction(imageSelector, imageIndex));
		}
	}
	
	function setImage(imageData) {
		if (checkLocked(setImage, [imageData])) {
			return;
		}

		if (currentImage === -1) {
			addImage(imageData);
		} else {
			const selector = getImageSelector(currentImage);
			const element = $(selector);
			const prevSrc = element.attr("src");
			element.attr("src", imageData.url);
			_actions.addAction(new SetAction(
				selector,
				ImageData.fromUrl(prevSrc),
				imageData))
		}
	}

	function showElement(show, elementSelector) {
		const element = $(elementSelector);
		element.css("display", show === true ? "block" : "none");
	}
		
	function toggleElementDisplay(selector) {
		const element = $(selector);
		const display = element.css('display');
		if (display === 'block') {
			element.css('display', 'none');
		} else {
			element.css('display', 'block');
		}
	}

	function startResize(event, imageIndex) {
		imageResizing = imageIndex;
		$("body").css("cursor", "se-resize");
		previousDragX = event.pageX;
		previousDragY = event.pageY;
	}

	function resizeAll() {
		const currentFrameWidth = $("body").width();
		if (initialFrameWidth === 0) {
			initialFrameWidth = currentFrameWidth;
			return;
		}
		const scale = initialFrameWidth / currentFrameWidth;
		const animationDuration = 200;

		// "border" : { "color": "black", "width": 4.5677 }
		const currentBorderWidth = borderProperties['border-width'];
		if (currentBorderWidth > 0) {
			setBorder('border-width', currentBorderWidth / scale, ActionContext.FROM_RESIZE);
		}

		const imageCount = getImageCount();
		let resizeCount = 0;
		for (let imageIndex = 0; resizeCount < imageCount; imageIndex++) {
			const containerSelector = getContainerSelector(imageIndex);
			const containerElement = $(containerSelector);
			if (containerElement.length === 0) {
				continue;
			}
			
			const imageSelector = getImageSelector(imageIndex)
			const currentImagePosition = $(containerElement).position();
	
			$(imageSelector).animate({
				width: $(imageSelector).width()  / scale
			}, animationDuration)
			$(containerSelector).animate({
				top: currentImagePosition.top / scale,
				left: currentImagePosition.left / scale
			}, animationDuration);
			
			resizeCount++;
		}
		initialFrameWidth = currentFrameWidth;
	}

	$("body").on('vmousemove', function(event) {
		if (imageResizing >= 0) {
			const deltaX = event.pageX - previousDragX;
			const deltaY = event.pageY - previousDragY;

			const element = $(getImageSelector(imageResizing));
			const elementWidth = element.width();
			element.css({
				width: elementWidth + deltaX
			});
			
			previousDragX = event.pageX;
			previousDragY = event.pageY;
		}
	});

	$("body").on('vmouseup', function() {
		if (imageResizing >= 0) {
			if (_deviceType === 'desktop') {
				showElement(false, getIndicatorContainerSelector(imageResizing));
				$(this).css("cursor", "default");
			}
			_actions.addAction(new ResizeAction(getImageSelector(imageResizing)));
			imageResizing = -1;
		}
	});
	
	let initialFrameWidth = $("body").width();
	let resizeTimer = null;
	$(window).resize(function () {
		// don't call resizeAll each time...
		if (resizeTimer !== null) {
			clearTimeout(resizeTimer);
		}
		resizeTimer = setTimeout(resizeAll, 200);
	});
    
    // Toolbar
    const toolbarButtonSpacing = 15;
    const singleButtonOffset = 24 + toolbarButtonSpacing;
    const collapseTimeout = 5000;
    const toolbarAnimationDuration = 200;
	let _toolbarTimer = null; // Timer to hide the toolbar on desktop
	let _buttonTimer = null;  // Timer to collapse the toolbar buttons
	
	function initDeviceType(deviceType) {

		if (_deviceType !== null) {
			// Already initialized
			return;
		}

		_deviceType = deviceType;

		const toggleButton = $("#togglebutton");
		features.forEach(feature => {

			const featureDesc = feature.type === 'toggle' ? feature.desc[0] : feature.desc;
			const featureClass = feature.type === 'toggle' ? feature.class[0] : feature.class;
			const featureButtonHtml = `<div id="${feature.selector.substring(1)}" class="toolbarbutton ${featureClass}" data-desc="${featureDesc}"></div>`;
			$(featureButtonHtml).insertBefore(toggleButton);

			const element = $(feature.selector);
			if (_deviceType === 'desktop') {
				element.on('mouseenter', function() {
					setButtonDesc($(this).attr('data-desc'));
					$("#buttondesc").stop(); // Stop possible current animation
					$("#buttondesc").animate({ opacity: 1 }, toolbarAnimationDuration);
				});
				element.on('mouseleave', function() {
					$("#buttondesc").stop(); // Stop possible current animation
					$("#buttondesc").animate({ opacity: 0 }, toolbarAnimationDuration);
				});
			}
			element.on('vclick', patchedClickHandler(function () {
				if (!$(this).hasClass('disabled')) {
					if (_deviceType === 'mobile') {
						clearTimeout(_buttonTimer);
						_buttonTimer = setTimeout(collapseToolbar, collapseTimeout);
					}
					feature.action();
				}
			}));
		});

		if (_deviceType === 'desktop') {
			// Show/Hide toolbar when mouse over the body
			$("body").on('mouseenter', function() {
				clearTimeout(_toolbarTimer);
				$("#toolbarcontainer").stop();
				$("#toolbarcontainer").animate({ top: 10 }, toolbarAnimationDuration);
			});
			$("body").on('mouseleave', function() {
				_toolbarTimer = setTimeout(collapseAndHideToolbar, 5000);
			});

			// clear/init timer to collapse the toolbar on mouseleave/mouseenter on any button
			$(".toolbarbutton").on('mouseleave', function() {
				_buttonTimer = setTimeout(collapseToolbar, collapseTimeout);
			});
			$(".toolbarbutton").on('mouseenter', function() {
				clearTimeout(_buttonTimer);
			});
		} else {
			// always show the toggle
			$("#toolbarcontainer").css({
					top: 10
			});
		}
		updateFeatureStatus();
	}

	function setButtonDesc(desc) {
		$("#buttondesc > span:first-child").text(desc);
	}

    $("#togglebutton").on('vclick', patchedClickHandler(toggleToolbar));
    
	function collapseAndHideToolbar() {
        collapseToolbar();
		$("#toolbarcontainer").stop();
        $("#toolbarcontainer").animate({ top: -34 }, toolbarAnimationDuration);
	}

    function toggleToolbar() {
        if (isToolbarExpanded()) {   
            collapseToolbar();
        } else {
            expandToolbar();
        }
    }
    function isToolbarExpanded() {
        return $("#toolbarcontainer").attr('expanded') === 'true';
    }
    function setToolbarExpanded(expanded) {
        $("#toolbarcontainer").attr('expanded', expanded);
    }
    function expandToolbar() {
        $(".toolbarbutton").each(function (index) {
            $(this).animate({
                left: - singleButtonOffset*(index+1),
                opacity: 1
            }, toolbarAnimationDuration);
        });
        $("#togglebutton").addClass("open");
        setToolbarExpanded(true);
        clearTimeout(_buttonTimer);
        _buttonTimer = setTimeout(collapseToolbar, collapseTimeout);
    }
    function collapseToolbar() {
        $(".toolbarbutton").each(function (index) {
            $(this).animate({ left: 0, opacity: 0 }, toolbarAnimationDuration);
        });
        $("#togglebutton").removeClass("open");
        setToolbarExpanded(false);
        clearTimeout(_buttonTimer);
	}
    function activateFunction(feature) {
		// If the feature is a toggle, isActive() returns the index of the active action (0 or 1)
		// Otherwise it returns a boolean (action is active or not)
		const isToggle = feature.type === 'toggle';
		const isActive = feature.isActive();
		const enable = isToggle ? isActive === 0 : isActive;
		const button = $(feature.selector);

        if (enable === true) {
			if (isToggle ===  false) {
				button.removeClass("disabled");
			}
			button.removeClass(`${feature.class}Off`);
            button.addClass(feature.class);
        } else {
			if (isToggle ===  false) {
				button.addClass("disabled");
			}
			button.addClass(`${feature.class}Off`);
			button.removeClass(feature.class);
		}
		if (isToggle === true) {
			const toggleDesc = feature.desc[isActive];
			button.attr('data-desc', toggleDesc);
			setButtonDesc(toggleDesc);
		}
    }

	// Remove jQuery mobile background color 
	$("body, body > div:first-child").css({
        "background-color" : "transparent",
        "overflow": "hidden",
		"height": "100%"
    });

	sendMessage({
		action: 'ready'
	})
});
</script>
</head>
<body>

<div id="lockOverlay">
	<div id="lockWarning">
		Votre simulation est verrouillée.<br>
		<button id="unlockButton">Déverrouiller et Exécuter</button>
	</div>
</div>

<p id="log" style="color: black; word-break: break-all;"></p>

<div id="toolbarcontainer" expanded="false">
	<div id="buttondesc"><span style="white-space: nowrap;"></span></div>
	<!-- Feature buttons will be inserted here -->
    <div id="togglebutton" class="toolbartoggle">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
    </div>
</div>

</body>
</html>